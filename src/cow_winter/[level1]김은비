온보딩
1.객체지향적프로그래밍이란?
프로그램을 여러 객체로 나누고, 객체 간의 상호작용을 통해 문제를 해결하는 방식

2.객체지향 프로그래밍의 장,단점
장점:
-상속을 통한 코드 재사용성
-캡슐화로 객체 내부의 세부 구현 숨기고, 외부에서 제공된 메서드만 사용해 유지보수성 향상
-다향성을 통한 동일한 인터페이스로 다양한 객체 처리해 확장성 제공
-캡슐화를 통해 데이터 접근 제한해 보안 강화
단점:
-초기 설계 복잡
-절차지향 프로그래밍에 비해 속도와 성능이 낮음
-단순한 프로그램에는 오히려 비효율적

3.절차지향과 객체지향의 차이
코드 구성 방식: 함수와 절차 중심/ 객체와 클래스 중심
코드 재사용성: 낮음/ 높음
유지보수: 함수간 의존성 높음/ 객체 단위로 수정 가능
확장성: 기능 추가시 기존 코드 수정 필요/ 새로운 객체나 클래스 추가로 확장 쉬움
속도: 빠름/ 느림

4.클래스와 객체
클래스란?
-객체를 생성하기 위한 틀로 속성과 메서드로 구성됨
객체란?
-클래스를 기반으로 생성된 실체
클래스와 객체의 차이
-클래스는 객체를 만들어내는 역할을 하고 객체는 이를 바탕으로 만들어진 실체이다
인스턴스란?
-클래스를 기반으로 생성된 객체 (객체>=인스턴스)
객체:클래스에서 만들어진 모든 실체
인스턴스:특정 클래스와 연관되어 있는 객체를 그 클래스의 인스턴스

5.추상화란?
복잡한 정보는 숨기고 필요한 정보만 표현
# 추상화: Person 클래스에서 공통된 기능만 정의하고, 구체적인 내용은 자식 클래스에서 구현
class Person:
    def introduce(self):
        pass  
        
6.캡슐화란?
객체의 속성에 접근 제한을 둠
-적절한 접근 제어자를 사용해야 하는 이유
외부에 공개할 필요 없는 정보를 감춰 클래스를 수정할떄 다른 부분에 영향을 미치지 않게 한다
접근 제어자를 통해 해당 속성이나 메서드가 외부에서 접근 해야하는지, 내부에서만 사용해야하는지 명확히 알 수 있다
객체의 무결성을 보장한다
# 캡슐화: 교수와 학생의 속성을 직접 접근 불가하게 설정
class Professor(Person):
    def introduce(self):
        print(f"안녕하세요, 저는 교수 {self.name}이고, {self.__department}학과에 속해 있습니다.")
    
    def set_details(self, name, department):
        self.name = name  # 속성 직접 할당
        self.__department = department  # 캡슐화된 속성

    def get_department(self):  # 캡슐화된 속성에 접근하는 방법 제공
        return self.__department

class Student(Person):
    def introduce(self):
        print(f"안녕하세요, 저는 학생 {self.name}이고, {self.__grade}학년입니다.")
    
    def set_details(self, name, grade):
        self.name = name  # 속성 직접 할당
        self.__grade = grade  # 캡슐화된 속성 

    def get_grade(self):  # 캡슐화된 속성에 접근하는 방법 제공
        return self.__grade

7.상속이란?
부모 클래스의 속성과 메서드를 자식 클래스가 물려 받음
# 상속: 교수와 학생은 사람(Person)을 상속받음

8.다형성이란?
동일한 메서드가 다양한 방식으로 동작함
# 다형성: 교수와 학생이 같은 introduce() 메서드를 다르게 구현
def introduce_person(person):
    person.introduce()  # 사람의 소개 메서드를 호출 (다형성 적용)

# 객체 생성
professor = Professor()
student = Student()

# 정보 설정 (set_details로 속성 직접 할당)
professor.set_details("김교수", "경영정보")
student.set_details("김학생", 2)

# 실행
introduce_person(professor)  # 출력: 안녕하세요, 저는 교수 김교수이고, 경영정보학과에 속해 있습니다.
introduce_person(student)    # 출력: 안녕하세요, 저는 학생 김학생이고, 2학년입니다.

# 캡슐화된 정보에 접근
print(professor.get_department())  # 출력: 경영정보
print(student.get_grade())     # 출력: 2

9.객체지향적 설계 원칙(SOLID)
객체지향 설계 원칙 중에서 유지보수가 쉬운 코드를 작성하기 위해 따르는 다섯가지 원칙
S: Single Responsibility Principle (단일 책임 원칙)
하나의 클래스는 하나의 책임만 가져야 한다
O: Open/Closed Principle (개방-폐쇄 원칙)
소프트웨어 엔티티는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다
L: Liskov Substitution Principle (리스코프 치환 원칙)
자식 클래스는 부모 클래스의 기능을 대체할 수 있어야 한다
I: Interface Segregation Principle (인터페이스 분리 원칙)
특정 클라이언트를 위한 인터페이스는 그 클라이언트가 사용하지 않는 메서드를 포함하면 안된다
D: Dependency Inversion Principle (의존 역전 원칙)
상위 모듈은 하위 모듈에 의존해서는 안된다. 두모듈은 추상화에 의존해야 한다

10.인터페이스와 추상클래스
-인터페이스란?
메서드 선언만 포함되어 있는 구현되지 않은 클래스
-추상클래스란?
구현된 메서드와 구현되지 않은 메서드를 혼합할 수 있는 클래스
-인터페이스와 추상클래스 차이점
메서드 구현 되지 않음/ 메서드 구현 가능, 일부는 추상 메서드로 남길 수 있음
다중 구현 가능/ 단일 상속만 가능
속성을 가질 수 없음/ 속성을 가질 수 있음
서로 관련 없은 클래스들이 공통된 행동을 가질 수 있도록 함/ 상속을 통해 기본 구현을 제공하고 하위클래스에서 확장

11.클린 코드란 무엇이며, 지켜야할 점들이 어떤 것들이 있는가?
클린코드란?
읽기 쉽고 이해하기 쉽고 유지보수가 용이한 코드
-의미 있는 이름 사용
-중복 코드 최소화
-조건문 단순화
-주석과 문서화
-일관된 규칙 유지
-에러 처리